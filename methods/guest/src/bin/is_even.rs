// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused_doc_comments)]
#![allow(unused_imports)]
#![no_main]

use alloy_primitives::{address, Address, U256};
use alloy_sol_types::{sol, SolValue};
use risc0_ethereum_view_call::{config::GNOSIS_CHAIN_SPEC, ethereum::EthViewCallInput, ViewCall};
use risc0_zkvm::guest::env;
risc0_zkvm::guest::entry!(main);
use k256::{
    ecdsa::{signature::Verifier, Signature, VerifyingKey},
    EncodedPoint,
};
use ark_bn254::Fr;
use ark_ff::{BigInteger, PrimeField};
use light_poseidon::{parameters::bn254_x5, Poseidon, PoseidonHasher};


sol! {
    interface POAP {
        function tokenDetailsOfOwnerByIndex(address owner, uint256 index) external view returns (uint256, uint256);
    }
}


const CONTRACT: Address = address!("22C1f6050E56d2876009903609a2cC3fEf83B415");
const CALLER: Address = address!("6f22b9f222D9e9AF4481df55B863A567dfe1dd42");


fn main() {
    // Read the input from the guest environment.
    let call_input: EthViewCallInput = env::read();
    let (encoded_verifying_key, message, signature, poap_index): (
        EncodedPoint,
        Vec<u8>,
        Signature,
        U256,
    ) = env::read();
    let verifying_key = VerifyingKey::from_encoded_point(&encoded_verifying_key).unwrap();

    // Verify the signature.
    verifying_key
        .verify(&message, &signature)
        .expect("Signature verification failed");

    // Generate hash from signature
    let mut poseidon = Poseidon::<Fr>::new_circom(1).unwrap();
    let input1 = Fr::from_be_bytes_mod_order(signature.to_bytes().as_slice());
    let signature_hash = poseidon.hash(&[input1]).unwrap();
    // println!("Poseidon hash: {}", signature_hash.to_string());

    // ViewCall to get event_id from poap_index
    let call: POAP::tokenDetailsOfOwnerByIndexCall = POAP::tokenDetailsOfOwnerByIndexCall {
        owner: CALLER,
        index: poap_index,
    };

    // Get the caller address from the verifying key.
    // let caller = Address::from_public_key(&verifying_key);

    // Converts the input into a `ViewCallEnv` for execution. The `with_chain_spec` method is used
    // to specify the chain configuration. It checks that the state matches the state root in the
    // header provided in the input.
    let view_call_env = call_input.into_env().with_chain_spec(&GNOSIS_CHAIN_SPEC);

    // Commit the block hash and number used when deriving `view_call_env` to the journal.
    env::commit(&view_call_env.block_commitment().abi_encode());

    // Execute the view call; it returns the result in the type generated by the `sol!` macro.
    let returns = ViewCall::new(call, CONTRACT)
        .with_caller(CALLER)
        .execute(view_call_env)
        .clone();

    // Commit the signature_hash and event_id
    env::commit(&signature_hash.to_string());
    env::commit(&returns._1);

    println!("View call result: {} , {}", returns._0, returns._1);
}
